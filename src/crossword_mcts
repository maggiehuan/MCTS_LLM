import re
import os
import json
from tot.tasks.base import Task, DATA_PATH
from tot.prompts.crosswords import * 
from tot.models import gpt
# import openai
# import torch
import torch.optim as optim
import numpy as np
from tot.prompts.crosswords import propose_prompt, value_prompt
import copy
from tot.models import gpt

class CrosswordsEnv:

    env = MiniCrosswordsTask(Task)

    def __init__(self, file='/home/ziyu/code/LLMs/mcts-llm/src/tot/data/crosswords/mini0505.json'):
        self.file = os.path.join(DATA_PATH, 'crosswords', file)
        self.file = json.load(open(self.file))
        self.n = len(self.file)
        self.idx = None
        self.times = 0

    def __len__(self): # question
        return self.n


    def prompt_wrap(self, observation):
            return propose_prompt.format(input=observation) 
            # breakpoint()

    def reset(self, idx): 
        self.idx = idx 
        # random.sample(idx)
        # if class
        self.data, self.board_gt = self.file[idx] 


    def reward(self, output: str):
        output = output.split('Output:\n')[-1]
        letters = []
        for i, line in enumerate(output.strip().split('\n')[-5:], 1):
            breakpoint()
            letters.extend(line.split(' ')[:5])



    def answered(self):
        response = gpt(self.prompt_wrap(env.render()), model='gpt-4', n=1)[0]
        if response == "answered":
            return True
        else:
            return False

    # def reset(self, idx, board=None, status=None, steps=None): 
    #     self.idx = idx 
    #     # random.sample(idx)
    #     # if class
    #     self.data, self.board_gt = self.file[idx] 
    #     self.board = ['_'] * 25 
    #     self.ans = ['_____'] * 10 
    #     breakpoint()
    #     self.ans_gt = self.get_ans(self.board_gt) 
    #     self.steps = 0 
    #     self.status = [0] * 10  # 0: unfilled; 1: filled; 2: filled then changed
    #     if board is not None: 
    #         self.board = board
    #         self.ans = self.get_ans(self.board) 
    #     if status is not None:
    #         self.status = status
    #     if steps is not None:
    #         self.steps = steps
    #     return self.render()  

    def get_ans(self, board):
        ans = [''] * 10
        for i in range(5):
            ans[i] = ''.join(board[i*5:(i+1)*5])
        for i in range(5):
            ans[i+5] = ''.join(board[i::5])
        return ans

class MiniCrosswordsTask(Task):
    """
    Input (x)   : Decription of a 5x5 mini crossword
    Output (y)  : List of 10 words to fill in the crossword
    Reward (r)  : word level and game level
    Input Example: 
    Output Example: 
    """
    def __init__(self, file):
        """
        file: a csv file (fixed)
        """
        super().__init__()
        self.env = CrosswordsEnv(file)  # use it as a stateless tool
        self.xs = []
        for idx in range(len(self.env)):
            self.env.reset(idx)
            #self.xs.append(self.env.render_clues())
        self.steps = 10  
        self.cache_proposals = {}

    def __len__(self) -> int:
        return len(self.env)


    def test_output(self, idx: int, output: str):
        self.env.reset(idx）# 拿出
        output = output.split('Output:\n')[-1]
        info = {'r_letter': 0}
        for i, line in enumerate(output.strip().split('\n')[-5:], 1):
            breakpoint()
            letters = line.split(' ')[:5] #需要append一下
            # print(action)
        info['r'] = info['r_word']
        return info

    def set_status(self, x: str, y: str):
        idx = self.xs.index(x)
        self.test_output(idx, y) 


### 测试实例
if __name__ == '__main__':
    file='/home/ziyu/code/LLMs/mcts-llm/src/tot/data/crosswords/mini0505.json'
    env = MiniCrosswordsTask(file)
    env.test_output(5)